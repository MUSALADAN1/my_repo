#!/usr/bin/env python3
"""
scripts/run_demo_backtest.py

Demo runner that:
 - creates synthetic OHLCV data,
 - plugs it into the Broker via a mock client,
 - registers a few strategies with StrategyManager,
 - runs a backtest feed,
 - logs signals and (simulated) orders to CSV.

Safe: no network calls, uses existing adapter/placeholders.
"""

import os
import sys
import csv
import json
from datetime import datetime, timezone, timedelta
import sys

# ensure project root is on sys.path so `import backend` works when running script directly
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))         # scripts/
PROJECT_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, ".."))  # project root
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

import pandas as pd
from backend.exchanges import create_adapter
from backend.exchanges.broker import Broker
from bot_core.strategy_manager import StrategyManager

# Import strategies you added earlier
from bot_core.strategies.sample_strategy import MovingAverageCrossoverStrategy
from bot_core.strategies.grid_strategy import GridTradingStrategy
from bot_core.strategies.dca_strategy import DCAStrategy

# ---------- Config ----------
SYMBOL = "BTC/USDT"
TIMEFRAME = "1h"   # our mock client accepts any string for timeframe
NBARS = 200        # number of synthetic bars
OUT_SIGNALS = "demo_signals.csv"
OUT_ORDERS = "demo_orders.csv"

# ---------- Synthetic OHLCV generator ----------
class SyntheticOHLCVClient:
    """
    Produces NBARS synthetic OHLCV rows:
      [timestamp_ms, open, high, low, close, volume]
    Simple sinusoidal + trend + noise pattern so strategies produce some signals.
    """
    def __init__(self, nbars=NBARS, start_price=100.0):
        self.nbars = nbars
        self.start_price = start_price

    def fetch_ohlcv(self, symbol, timeframe, limit):
        import math, random
        base_ts = int(datetime.now(timezone.utc).timestamp() * 1000) - (self.nbars * 3600 * 1000)
        rows = []
        price = self.start_price
        for i in range(self.nbars):
            # a slow uptrend + sinusoidal wave + small noise
            trend = 0.02 * i / max(1, self.nbars)        # small drift
            wave = math.sin(i * 0.12) * 1.5
            noise = (random.random() - 0.5) * 0.6
            open_p = price + trend + wave * 0.2 + noise * 0.2
            high_p = open_p + abs(wave) * 0.6 + 0.2
            low_p = open_p - abs(wave) * 0.6 - 0.2
            close_p = open_p + wave * 0.1 + (random.random() - 0.5) * 0.3
            vol = 100 + int(abs(wave) * 50 + random.random() * 20)
            ts = base_ts + i * 3600 * 1000  # hourly bars
            rows.append([ts, round(open_p, 6), round(high_p, 6), round(low_p, 6), round(close_p, 6), vol])
            price = close_p  # next open evolves from close
        # return last `limit` bars
        return rows[-limit:]

# ---------- Demo runner ----------
def run_demo():
    # prepare client + adapter + broker
    client = SyntheticOHLCVClient(nbars=NBARS, start_price=100.0)
    adapter = create_adapter("binance", {"client": client})
    broker = Broker(adapter_instance=adapter)
    broker.connect()

    # prepare strategy manager and register three strategies
    sm = StrategyManager()

    # Moving Average Crossover (short=5,long=20)
    ma = sm.register_strategy(MovingAverageCrossoverStrategy, params={"short":5, "long":20})
    # Grid between 110 and 80, 6 levels
    grid = sm.register_strategy(GridTradingStrategy, params={"grid_start":110.0, "grid_end":80.0, "levels":6})
    # DCA: buy every 30 bars up to 3 times
    dca = sm.register_strategy(DCAStrategy, params={"interval_bars": 30, "total_steps": 3, "amount_per_step": 1.0})

    sm.initialize_all(broker)

    # run backtest
    print("Running demo backtest (this may take a few seconds)...")
    result = sm.run_backtest(broker, SYMBOL, TIMEFRAME, limit=NBARS)

    signals = result.get("signals", [])
    print(f"Collected {len(signals)} signals from strategies.")

    # Ensure output folder exists
    out_dir = os.getcwd()
    signals_path = os.path.join(out_dir, OUT_SIGNALS)
    orders_path = os.path.join(out_dir, OUT_ORDERS)

    # Save signals to CSV
    if signals:
        # Normalize keys for CSV (collect union of keys)
        keys = set()
        for s in signals:
            keys.update(s.keys())
        keys = sorted(list(keys))
        with open(signals_path, "w", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=keys)
            writer.writeheader()
            for s in signals:
                # serialize datetimes
                row = dict(s)
                if "bar_time" in row and not isinstance(row["bar_time"], str):
                    row["bar_time"] = str(row["bar_time"])
                writer.writerow(row)
        print(f"Signals saved to {signals_path}")
    else:
        print("No signals to save.")

    # Simulate placing orders for each signal (simple mapping)
    orders = []
    for s in signals:
        sig = s.get("signal")
        if sig in ("long", "buy", "buy_option"):
            # simple market buy simulation
            try:
                price = s.get("price", None)
                amount = s.get("amount", 0.001) or 0.001
                order = broker.place_order(SYMBOL, "buy", float(amount), price=price)
                orders.append({"signal": sig, "strategy": s.get("strategy"), "order": order})
            except Exception as e:
                orders.append({"signal": sig, "strategy": s.get("strategy"), "error": str(e)})
        elif sig in ("sell", "exit", "short"):
            try:
                price = s.get("price", None)
                amount = 0.001
                order = broker.place_order(SYMBOL, "sell", float(amount), price=price)
                orders.append({"signal": sig, "strategy": s.get("strategy"), "order": order})
            except Exception as e:
                orders.append({"signal": sig, "strategy": s.get("strategy"), "error": str(e)})

    # Save orders to CSV
    if orders:
        # flatten order dicts a little for CSV
        with open(orders_path, "w", newline="") as f:
            fieldnames = ["signal", "strategy", "order_id", "order_status", "raw"]
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            for o in orders:
                order = o.get("order") or {}
                if isinstance(order, dict):
                    oid = order.get("id") or order.get("order_id") or ""
                    status = order.get("status") or ""
                    raw = json.dumps(order.get("raw", order), default=str)
                else:
                    oid = str(order)
                    status = ""
                    raw = json.dumps(order, default=str)
                writer.writerow({
                    "signal": o.get("signal"),
                    "strategy": o.get("strategy"),
                    "order_id": oid,
                    "order_status": status,
                    "raw": raw
                })
        print(f"Orders saved to {orders_path}")
    else:
        print("No orders placed.")

    print("Demo finished. Inspect the CSV files or open them in Excel / VSCode.")

if __name__ == "__main__":
    run_demo()
